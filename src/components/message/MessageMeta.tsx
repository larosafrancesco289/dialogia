'use client';
import type { Message, Chat, ORModel } from '@/lib/types';
import { computeCost } from '@/lib/cost';

export function MessageMeta({
  message,
  modelId,
  chatSettings,
  models,
  showStats,
}: {
  message: Message;
  modelId: string;
  chatSettings: Chat['settings'];
  models: ORModel[];
  showStats: boolean;
}) {
  const modelInfo = models.find((x) => x.id === modelId);
  let cost: string | undefined;
  let ctxPct: number | undefined;
  if (showStats && message.metrics) {
    const pt = message.metrics.promptTokens ?? message.tokensIn;
    const ct = message.metrics.completionTokens ?? message.tokensOut;
    const { currency, total } = computeCost({
      model: modelInfo,
      promptTokens: pt,
      completionTokens: ct,
    });
    cost = total && total > 0 ? `${currency} ${total.toFixed(5)}` : undefined;
    const contextLimit = modelInfo?.context_length ?? 8000;
    const reservedForCompletion =
      typeof chatSettings.max_tokens === 'number' ? chatSettings.max_tokens! : 1024;
    const maxPromptTokens = Math.max(512, contextLimit - reservedForCompletion);
    if (pt != null && maxPromptTokens > 0) {
      ctxPct = Math.max(0, Math.min(100, Math.round((pt / maxPromptTokens) * 100)));
    }
  }

  return (
    <>
      Generated by <span className="badge">{modelId}</span>
      {showStats && message.metrics && (
        <>
          <span> · TTFT {message.metrics.ttftMs ?? '–'} ms</span>
          {message.metrics.promptTokens != null && (
            <span> · in {message.metrics.promptTokens}</span>
          )}
          {message.metrics.completionTokens != null && (
            <span> · out {message.metrics.completionTokens}</span>
          )}
          {message.metrics.tokensPerSec != null && (
            <span> · {message.metrics.tokensPerSec} tok/s</span>
          )}
          {ctxPct != null && <span title="Context window fullness"> · ctx {ctxPct}%</span>}
          {cost && <span> · {cost}</span>}
        </>
      )}
    </>
  );
}
